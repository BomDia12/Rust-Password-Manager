<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Gerenciador de senhas CLI"><title>cli_password_manager - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-cb6f1f67f1bcd037.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="cli_password_manager" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0 (cc66ad468 2023-10-03)" data-channel="1.73.0" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-1596385f77d47ef2.css" data-theme-dark-css="dark-0a43001d3fc2282c.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-1596385f77d47ef2.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-0a43001d3fc2282c.css"><link rel="stylesheet" href="../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../cli_password_manager/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../cli_password_manager/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate cli_password_manager</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.1.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‚ÄòS‚Äô to search, ‚Äò?‚Äô for more options‚Ä¶" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">cli_password_manager</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/cli_password_manager/main.rs.html#1-239">source</a> ¬∑ <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="gerenciador-de-senhas-cli"><a href="#gerenciador-de-senhas-cli">Gerenciador de senhas CLI</a></h2>
<p>Este projeto foi desenvolvido em Rust no contexto da disciplina Linguagens de Program√ß√£o
ministrada pelo professor Marcelo Ladeira. Ele visa explorar a linguagem Rust que foi escolhida pela turma
como a Linguagem a ser usada no desenvolvimento dos projetos.</p>
<h2 id="desenvolvedores"><a href="#desenvolvedores">Desenvolvedores</a></h2>
<ul>
<li>Ana Paula Oliveira da N√≥brega Costa (190142120)</li>
<li>Arthur Mota Furtado (200014935)</li>
<li>Gabriel Cruz Vaz Santos (200049038)</li>
<li>N√≠colas Paulin Benatto (200025627)</li>
<li>Vanessa Paix√£o Costa (200028286)</li>
</ul>
<h2 id="caracter√≠sticas-da-linguagem-rust"><a href="#caracter√≠sticas-da-linguagem-rust">Caracter√≠sticas da Linguagem Rust</a></h2>
<p>Rust foi uma linguagem de programa√ß√£o desenvolvida por Graydon Hoare, e lan√ßada em 2015. Ela tem como dom√≠nio
principal da linguagem o desenvolvimento de sistemas, e √© uma linguagem multi-paradigmas, com ferramentas que 
permitem que ela seja utilizada tanto como uma linguagem imperativa, orientada a objetos, ou funcional.</p>
<p>Durante o seu desenvolvimento, o principal foco que rust teve foi em segura√ßa de mem√≥ria, com um compilador,
que for√ßa um conjunto de regras, visando uma maior seguran√ßa em c√≥digo Rust. N√£o s√≥ isso, mas o funcionamento
do Borrow-checker, uma inova√ß√£o do Rust, que prop√µe uma nova forma de lidar com vari√°veis, permite que o
programador n√£o lide diretamente com gerenciamento de mem√≥ria, mas retira a necessidade de um Garbage collector,
algo que diminui a performance das aplica√ß√µes de linguagens que a implementam.</p>
<p>Um outro foco que Rust teve, em seu desenvolvimento, √© a cria√ß√£o de arquivos compilados pequenos, o que permite que
seja uma linguagem com grande aplicabilidade no setor de embarcados.</p>
<h3 id="avalia√ßao-da-linguagem-em-rela√ß√£o-aos-crit√©rios-de-avalia√ß√£o"><a href="#avalia√ßao-da-linguagem-em-rela√ß√£o-aos-crit√©rios-de-avalia√ß√£o">Avalia√ßao da linguagem em rela√ß√£o aos crit√©rios de avalia√ß√£o</a></h3><h4 id="legibilidade"><a href="#legibilidade">Legibilidade</a></h4>
<p>Rust √© uma linguagem muito estruturada, e, uma vez que o programador √© familiar com o funcionamento
da linguagem, a forma como o compilador for√ßa o c√≥digo a ser escrito √© muito mais f√°cil de se entender
do que √© poss√≠vel em uma linguagem como C.</p>
<p>Um exmplo claro disso, √© a forma como Rust implementa mutabilidade. Por padr√£o, as vari√°veis em Rust s√£o constantes
e tem que ter um tipo a mais (<code>mut</code>) para serem mut√°veis. Dessa forma, o programador, ao ler o c√≥digo, entende
exatamente quais vari√°veis ser√£o mudadas ao longo do desenvolvimento e quais n√£o ser√£o.</p>
<p>Rust tem muitas ferramentas que facilitam a leitura de c√≥digo, uma das principais √© o seu robusto sistema de tipagem.
Em Rust, todos os tipos b√°sicos s√£o bem intuitivos, com os inteiros (<code>u8</code>, <code>i8</code>, <code>u16</code>, ‚Ä¶), por exemplo,
explicitando se o tipo possui sinal, e quantos bits o tipo tem (algo mais intuitivo que <code>char</code>, <code>short</code>, <code>int</code>,
<code>long</code> e <code>long long</code>). Por√©m, as estruturas de dados mais poderosas de Rust tem que ser Enums, e Structs. Embora
inicialmente sejam parecidas com as estruras similares em C, elas possuem algumas ferramentas que as tornam muito
mais √∫teis.</p>
<p>Quando se trata de Structs, em Rust, elas t√™m um funcionamento similar a Classes, em linguagem orientadas a objetos.
Por meio da keyword <code>impl</code> √© poss√≠vel implementar m√©todos para essas Structs, tanto m√©todos gerais, que n√£o necessitam de
uma inst√¢ncia da Struct, quanto m√©todos espec√≠ficos, que utlizam ou modificam o objeto que chamou a fun√ß√£o. Al√©m
disso, quando uma Struct √© declarada em um m√≥dulo, ela pode especificar quais propriedades da Struct s√£o p√∫blicas
e quais s√£o privadas.</p>
<p>Em rela√ß√£o a Enums, Rust os suporta como uma das principais estruturas de dados da linguagem. Tendo isso em vista,
Rust permite que cada valor enumerado receba uma vari√°vel de um tipo diferente, o que facilita muito lidar com,
por exemplo, endere√ßos de ip, como visto no c√≥digo abaixo:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">enum </span>IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}</code></pre></div>
<p>Al√©m disso, Rust tamb√©m permite a implementa√ß√£o de m√©todos novos para Enums, assim como para Structs.</p>
<p>Por ultimo, mas n√£o menos importante, devido a implenta√ß√£o de mutabilidade como um tipo em Rust, a assinatura das
fun√ß√µes informa muito mais o usu√°rio, uma vez que explicita se a fun√ß√£o modifica, ou n√£o um par√¢metro, o que evita
erros de efeitos colaterais quando usando um biblioteca externa.</p>
<h4 id="capacidade-de-escrita"><a href="#capacidade-de-escrita">Capacidade de Escrita</a></h4>
<p>Uma caracter√≠stica de Rust que aumenta a habilidade de escrita √© como ele lida com o an√°logo dele aos ponteiros de C.
Em rust, um refer√™ncia tamb√©m √© escrita como <code>&amp;var</code> sendo <code>var</code> a vari√°vel que ser√° referenciada. Por√©m,
o programador n√£o precisa adicionar alguma informa√ß√£o (o <code>*</code> do C) para utilizar a
refer√™ncia, basta colocar o par√¢metro que ser√° utilizado, o compilador automaticamente traduz a refer√™ncia
para o valor que deve ser usado.</p>
<p>Em termos mais gerais, n√£o tem uma capacidade de escrita muito elevada. Como o principal foco de Rust √© confian√ßa e
seguran√ßa, o compilador aplica muitas regras que o programador deve seguir, se n√£o o programa n√£o compila. Um bom
exemplo disso √© o borrow-checker, que deixa a passagem de par√¢metros muito mais complicada em Rust.</p>
<p>Por outro lado, Rust possui um bom suporte para a abstra√ß√£o, com a adi√ß√£o de m√©todos a structs e enums sendo um bom
exemplo disso. Uma outra forma que Rust aumenta o suporte para a abstra√ß√£o √© a facilidade com que voc√™ pode segregar
diferentes partes do c√≥digo para que um arquivo s√≥ exporte as fun√ß√µes finais que ele implementa, n√£o qualquer uma 
intermediaria, que seja para uso apenas interno.</p>
<p>Em termos de expressividade e sintaxe, Rust √© bem similar a C.</p>
<p>Um outro ponto que auxilia muito na capacidade de escrita do Rust √© o seu compilador. O Compilador Rust √© muito bom
em encontrar poss√≠veis problemas no c√≥digo, e, quando ele mostra um erro, ele explicita em que parte do c√≥digo o erro foi
cometido, e ainda d√° dicas de como resolver o erro.</p>
<h4 id="confiabilidade"><a href="#confiabilidade">Confiabilidade</a></h4>
<p>Confiabilidade √© a √°rea em que Rust mais se destaca. Como o foco inteiro da linguagem √© seguran√ßa, muito trabalho
foi realizado para que a linguagem seja o mais confi√°vel possivel.</p>
<p>Rust tem uma verifica√ß√£o de tipos est√°tica, em tempo de compila√ß√£o. Mas n√£o s√≥ isso, Rust implementa com tipos
algumas coisas que outras linguagens deixariam a parte, como exce√ß√µes e mutabilidade. A forma como Rust lida com
a checagem de Structs ou Enums que tenham os mesmos tipos internos, mas nomes diferentes √© com a checagem de nomes,
o que tamb√©m aumenta a confiabilidade na linguagem.</p>
<p>Tratamento de exce√ß√µes. Rust √© muito bom no quesito tratamento de exce√ß√µes. Como dito anteriormente, Rust lida com
exce√ß√µes, na maioria das vezes como um tipo, com fun√ß√µes que podem falhar retornando o seguinte Enum:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">enum </span><span class="prelude-ty">Result</span>&lt;T, E&gt; {
    <span class="prelude-val">Ok</span>(T),
    <span class="prelude-val">Err</span>(E),
}</code></pre></div>
<p>Dessa forma, o Usu√°rio √© obrigado a lidar com o erro de alguma forma antes de poder usar o resultado da fun√ß√£o. N√£o
s√≥ isso, mas o Rust incentiva o tratamento de exce√ß√µes e a lidar com diferentes valores de uma vari√°vel com uma express√£o
<code>match</code>, que, embora inicialmente pare√ßa similar a um <code>switch-case</code>, for√ßa o programador a lidar com todos os valores poss√≠veis
para aquela vari√°vel, o que aumenta muito a confiabilidade.</p>
<p>Mas, o que √© provavelmente a maior raz√£o para a confiabilidade do Rust √© o Borrow-checker. Esta √© um etapa na compila√ß√£o que
imp√µe um conjunto de regras que tem como objetivo minimizar os problemas que o programador pode ter com efeitos colaterais e
os valores dentro de uma fun√ß√£o. O que o Borrow-checker imp√µe √© que cada vari√°vel s√≥ pode ter um ‚Äúdono‚Äù, e, assim que este dono
acaba de ser executado, a vari√°vel √© liberada da mem√≥ria (√© assim que Rust consegue n√£o fazer uso de um Garbage collector). Al√©m disso,
por padr√£o, apenas a fun√ß√£o que √© ‚Äúdona‚Äù da vari√°vel pode modificar a vari√°vel. Nesse vi√©s, para passarmos par√¢metros em Rust, podemos
fazer de 3 formas diferentes.</p>
<p>Passagem por refer√™ncia:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>fun(a: <span class="kw-2">&amp;</span>i32) -&gt; i32 {
    a + <span class="number">10
</span>}
 
<span class="kw">fn </span>main () {
    <span class="kw">let </span>a = <span class="number">1</span>;
    <span class="kw">let </span>b = fun(<span class="kw-2">&amp;</span>a);
    <span class="macro">println!</span>(<span class="string">&quot;a : {}; b : {}&quot;</span>, <span class="kw-2">&amp;</span>a, <span class="kw-2">&amp;</span>b);
}</code></pre></div>
<p>Na passagem por refer√™ncia, a fun√ß√£o que recebe a vari√°vel apenas consegue l√™-la, n√£o edit√°-la, o que evita efeitos colaterais.
Uma vari√°vel pode ser referenciada v√°rias vezes ao mesmo tempo.</p>
<p>Passagem por refer√™ncia mut√°vel:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>fun(a: <span class="kw-2">&amp;mut </span>i32) {
    a += <span class="number">10</span>;
}
 
<span class="kw">fn </span>main () {
    <span class="kw">let </span>a = <span class="number">1</span>;
    fun(<span class="kw-2">&amp;mut </span>a);
    <span class="macro">println!</span>(<span class="string">&quot;a : {};&quot;</span>, <span class="kw-2">&amp;</span>a);
}</code></pre></div>
<p>Na passagem por refer√™ncia mut√°vel, a fun√ß√£o chamada pode modificar a vari√°vel passada, mas a fun√ß√£o chamadora ainda √© a dona
da vari√°vel. Como isso pode causar efeito colateral, apenas um fun√ß√£o pode acessar uma vari√°vel por refer√™ncia mut√°vel por
vez, e n√£o permite que a vari√°vel seja lida at√© que a fun√ß√£o chamada resolva, para evitar efeitos colaterais negativos.</p>
<p>Passagem de posse:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>fun(a: i32) -&gt; i32 {
    a += <span class="number">10</span>;
}
 
<span class="kw">fn </span>main () {
    <span class="kw">let </span>a = <span class="number">1</span>;
    <span class="kw">let </span>a = fun(a);
    <span class="macro">println!</span>(<span class="string">&quot;a : {};&quot;</span>, <span class="kw-2">&amp;</span>a);
}</code></pre></div>
<p>Quando um fun√ß√£o √© chamada por passagem de posse, a fun√ß√£o chamada vira a dona do valor passado, dessa forma, a fun√ß√£o
chamadora perde acesso aquela vari√°vel e n√£o consegue mais utilizar aquela vari√°vel.</p>
<p>Com essas 3 formas de passagem de par√¢metros Rust deixa problemas com valores inesperados de vari√°veis algo praticamente imposs√≠vel
de acontecer.</p>
<h4 id="custo"><a href="#custo">Custo</a></h4>
<ul>
<li>
<p>Custo de treinamento:</p>
<ul>
<li>O Custo de treinamento em Rust √© bem elevado, uma vez que √© uma linguagem bem complexa, com muitos conceitos n√£o observados
em outras linguagens</li>
</ul>
</li>
<li>
<p>Custo para escrever programas</p>
<ul>
<li>Em Rust o custo para escrever programas √© similar ao C, talvez um pouco maior devido ao Borrow-checker, mas isso √©
contrabalanceado pela maior legibilidade</li>
</ul>
</li>
<li>
<p>Custo para compilar programas</p>
<ul>
<li>A primeira compila√ß√£o em Rust √© mais demorada que em C, por√©m, devido a √≥tima ferramenta que √© o cargo, as pr√≥ximas compila√ß√µes
tendem a ser muito mais r√°pidas, devido ao cargo s√≥ compilar as partes modificadas do c√≥digo.</li>
</ul>
</li>
<li>
<p>Custo para executar programas</p>
<ul>
<li>A performance de Rust √© muito similar √† de C.</li>
</ul>
</li>
<li>
<p>Custo do sistema de implementa√ß√£o da linguagem</p>
<ul>
<li>Rust e todas as ferramentas padr√£o utilizadas pela comunidade s√£o open source, ent√£o o custo √© zero.</li>
</ul>
</li>
<li>
<p>Custo da m√° confiabilidade em sistemas cr√≠ticos</p>
<ul>
<li>Rust √© uma das linguagens mais confi√°veis utilizadas ultimamente, uma vez que ativamente pro√≠be problemas que levam a bugs.</li>
</ul>
</li>
<li>
<p>Custo da manuten√ß√£o dos programas</p>
<ul>
<li>Rust tem uma legibilidade maior que C, mas uma capacidade de escrita um pouco pior que C, ent√£o, no geral √© mais f√°cil de
manter uma base de c√≥digo em Rust do que em C.</li>
</ul>
</li>
</ul>
<h4 id="portabilidade"><a href="#portabilidade">Portabilidade</a></h4>
<p>A portabilidade de Rust √© similar a de C, ele deve ser compilado para cada plataforma na qual ele ser√° utilizado, mas suporta
quase todas as plataformas.</p>
<h4 id="generalidade"><a href="#generalidade">Generalidade</a></h4>
<p>Neste quesito, eu diria que Rust √© mais geral que C, uma vez que pode ser aplicado tanto no kernel linux e embarcados, at√© em
aplica√ß√µes web front-end com web assembly.</p>
<h4 id="qualidade-da-defini√ß√£o"><a href="#qualidade-da-defini√ß√£o">Qualidade da defini√ß√£o</a></h4>
<p>Rust tem uma documenta√ß√£o fenomenal, e muitos conte√∫dos online que facilitam o aprendizado, e o funcionamento de todas as 
features.</p>
<h2 id="funcionamento-do-projeto"><a href="#funcionamento-do-projeto">Funcionamento do Projeto</a></h2>
<p>O projeto √© divido em m√≥dulos que implementam cada parte do c√≥digo. Os M√≥dulos est√£o detalhados abaixo.</p>
<p>O c√≥digo pode ser rodado a partir do arquivo em <code>./target/release/cli-password-manager</code>. √â poss√≠vel que o c√≥digo n√£o rode em
algum outro sistema operacional, para o qual o projeto foi compilado. Caso isso seja verdade, o projeto pode ser compilado com
o aux√≠lio do cargo por meio do comando <code>cargo run</code>, esse comando compila e imediatamente roda o execut√°vel.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="encryption/index.html" title="mod cli_password_manager::encryption">encryption</a></div><div class="desc docblock-short">M√≥dulo que lida da encripta√ß√£o e decripta√ß√£o dos dados gerados</div></li><li><div class="item-name"><a class="mod" href="interfaces/index.html" title="mod cli_password_manager::interfaces">interfaces</a></div><div class="desc docblock-short">M√≥dulo que implementa as interfaces que integragem com o usu√°rio</div></li><li><div class="item-name"><a class="mod" href="persistency/index.html" title="mod cli_password_manager::persistency">persistency</a></div><div class="desc docblock-short">M√≥dulo que implementa a persist√™ncia das senhas guardadas</div></li><li><div class="item-name"><a class="mod" href="suggest_password/index.html" title="mod cli_password_manager::suggest_password">suggest_password</a></div><div class="desc docblock-short">M√≥dulo que cria uma senha aleat√≥ria para o usu√°rio</div></li><li><div class="item-name"><a class="mod" href="types/index.html" title="mod cli_password_manager::types">types</a></div><div class="desc docblock-short">M√≥dulo que implementa o tipo b√°sico utilizado pela maioria do projeto</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.main.html" title="fn cli_password_manager::main">main</a><span title="Restricted Visibility">&nbsp;üîí</span> </div><div class="desc docblock-short">¬†Fun√ß√£o geral do c√≥digo, apenas chama a <a href="cli::login_menu">fun√ß√£o de login da interface cli</a></div></li></ul></section></div></main></body></html>
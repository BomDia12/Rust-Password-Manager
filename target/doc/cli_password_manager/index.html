<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Gerenciador de senhas CLI"><title>cli_password_manager - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-f0d0e155d187fa31.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="cli_password_manager" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0 (90c541806 2023-05-31) (built from a source tarball)" data-search-js="search-e077946657036a58.js" data-settings-js="settings-298e1ea74db45b39.js" data-settings-css="settings-7bfb4c59cc6bc502.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-f61008743c98d196.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../cli_password_manager/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../cli_password_manager/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate cli_password_manager</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.1.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‚ÄòS‚Äô to search, ‚Äò?‚Äô for more options‚Ä¶" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">cli_password_manager</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/cli_password_manager/main.rs.html#1-343">source</a> ¬∑ <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="gerenciador-de-senhas-cli"><a href="#gerenciador-de-senhas-cli">Gerenciador de senhas CLI</a></h2>
<p>Este projeto foi desenvolvido em Rust no contexto da disciplina Linguagens de Program√ß√£o
ministrada pelo professor Marcelo Ladeira. Ele visa explorar a linguagem Rust que foi escolhida pela turma
como a Linguagem a ser usada no desenvolvimento dos projetos.</p>
<h2 id="desenvolvedores"><a href="#desenvolvedores">Desenvolvedores</a></h2>
<ul>
<li>Ana Paula Oliveira da N√≥brega Costa (190142120)</li>
<li>Arthur Mota Furtado (200014935)</li>
<li>Gabriel Cruz Vaz Santos (200049038)</li>
<li>N√≠colas Paulin Benatto (200025627)</li>
<li>Vanessa Paix√£o Costa (200028286)</li>
</ul>
<h2 id="caracter√≠sticas-da-linguagem-rust"><a href="#caracter√≠sticas-da-linguagem-rust">Caracter√≠sticas da Linguagem Rust</a></h2>
<p>Rust foi uma linguagem de programa√ß√£o desenvolvida por Graydon Hoare, e lan√ßada em 2015. Ela tem como dom√≠nio
principal da linguagem o desenvolvimento de sistemas, e √© uma linguagem multi-paradigmas, com ferramentas que 
permitem que ela seja utilizada tanto como uma linguagem imperativa, orientada a objetos, ou funcional.</p>
<p>Durante o seu desenvolvimento, o principal foco que rust teve foi em segura√ßa de mem√≥ria, com um compilador,
que for√ßa um conjunto de regras, visando uma maior seguran√ßa em c√≥digo Rust. N√£o s√≥ isso, mas o funcionamento
do Borrow-checker, uma inova√ß√£o do Rust, que prop√µe uma nova forma de lidar com vari√°veis, permite que o
programador n√£o lide diretamente com gerenciamento de mem√≥ria, mas retira a necessidade de um Garbage collector,
algo que diminui a performance das aplica√ß√µes de linguagens que a implementam.</p>
<p>Um outro foco que Rust teve, em seu desenvolvimento, √© a cria√ß√£o de arquivos compilados pequenos, o que permite que
seja uma linguagem com grande aplicabilidade no setor de embarcados.</p>
<h3 id="construtores"><a href="#construtores">Construtores</a></h3>
<p>Em geral, os construtores de Rust s√£o bem similares aos de C, com alguns diferen√ßas marcantes. Primeiro, em Rust, o tipo
da vari√°vel, sempre que poss√≠vel, √© inferido do contexto, por exemplo:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>a = <span class="number">5
</span><span class="kw">let </span>b: i32 = <span class="number">5</span></code></pre></div>
<p>Dessa forma, o Rust diminui a quantidade de boilerplates, enquanto mant√©m a tipagem est√°tica.</p>
<p>Para declaramos fun√ß√µes, utilizamos a seguinte sintaxe</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>main(arg1: type1) -&gt; return_type {
}</code></pre></div>
<p>Com os tipos dos argumentos e o tipo de retorno (a n√£o ser que a fun√ß√£o n√£o tenha um retorno, nesse caso, a parte do tipo de
retorno pode ficar vazia). Para retornar o que est√° dentro da fun√ß√£o podemos colocar a palavra-chave <code>return</code>, ou, se estamos
no final da fun√ß√£o, apenas colocar o valor a ser retornado sem <code>;</code> depois:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>vezes_2(x: i32) -&gt; i32 {
    x * <span class="number">2
</span>}</code></pre></div>
<p>ou</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>vezes_2(x: i32) -&gt; i32 {
    <span class="kw">return </span>x * <span class="number">2</span>;
}</code></pre></div>
<p>Structs e Enums s√£o declaradas de formas similares a C. </p>
<h3 id="avalia√ßao-da-linguagem-em-rela√ß√£o-aos-crit√©rios-de-avalia√ß√£o"><a href="#avalia√ßao-da-linguagem-em-rela√ß√£o-aos-crit√©rios-de-avalia√ß√£o">Avalia√ßao da linguagem em rela√ß√£o aos crit√©rios de avalia√ß√£o</a></h3><h4 id="legibilidade"><a href="#legibilidade">Legibilidade</a></h4>
<p>Rust √© uma linguagem muito estruturada, e, uma vez que o programador √© familiar com o funcionamento
da linguagem, a forma como o compilador for√ßa o c√≥digo a ser escrito √© muito mais f√°cil de se entender
do que √© poss√≠vel em uma linguagem como C.</p>
<p>Um exmplo claro disso, √© a forma como Rust implementa mutabilidade. Por padr√£o, as vari√°veis em Rust s√£o constantes
e tem que ter um tipo a mais (<code>mut</code>) para serem mut√°veis. Dessa forma, o programador, ao ler o c√≥digo, entende
exatamente quais vari√°veis ser√£o mudadas ao longo do desenvolvimento e quais n√£o ser√£o.</p>
<p>C√≥digo C</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>int multiplica_por_x(int valor) {
    int x = <span class="number">10</span>;
    <span class="kw">return </span>x * valor;
}</code></pre></div>
<p>C√≥digo Rust</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>multiplica_por_x(valor: i32) -&gt; i32 {
    <span class="kw">let </span>x = <span class="number">10</span>;
    x * valor
}</code></pre></div>
<p>Rust tem muitas ferramentas que facilitam a leitura de c√≥digo, uma das principais √© o seu robusto sistema de tipagem.
Em Rust, todos os tipos b√°sicos s√£o bem intuitivos, com os inteiros (<code>u8</code>, <code>i8</code>, <code>u16</code>, ‚Ä¶), por exemplo,
explicitando se o tipo possui sinal, e quantos bits o tipo tem (algo mais intuitivo que <code>char</code>, <code>short</code>, <code>int</code>,
<code>long</code> e <code>long long</code>). Por√©m, as estruturas de dados mais poderosas de Rust tem que ser Enums, e Structs. Embora
inicialmente sejam parecidas com as estruras similares em C, elas possuem algumas ferramentas que as tornam muito
mais √∫teis.</p>
<p>Quando se trata de Structs, em Rust, elas t√™m um funcionamento similar a Classes, em linguagem orientadas a objetos.
Por meio da keyword <code>impl</code> √© poss√≠vel implementar m√©todos para essas Structs, tanto m√©todos gerais, que n√£o necessitam de
uma inst√¢ncia da Struct, quanto m√©todos espec√≠ficos, que utlizam ou modificam o objeto que chamou a fun√ß√£o. Al√©m
disso, quando uma Struct √© declarada em um m√≥dulo, ela pode especificar quais propriedades da Struct s√£o p√∫blicas
e quais s√£o privadas. O √∫nico ponto em que Structs se diferenciam de Classes, √© a falta de Heran√ßas.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>Struct Pessoa {
    primeiro_nome: String,
    sobrenome: String,
    cpf: String,
}
 
<span class="kw">impl </span>Pessoa {
    <span class="kw">fn </span>nome_completo(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; String {
        <span class="kw">let </span><span class="kw-2">mut </span>res = <span class="self">self</span>.primeio_nome.clone;
        res.push_str(<span class="kw-2">&amp;</span><span class="self">self</span>.sobrenome);
        res
    }
}</code></pre></div>
<p>Em rela√ß√£o a Enums, Rust os suporta como uma das principais estruturas de dados da linguagem. Tendo isso em vista,
Rust permite que cada valor enumerado receba uma vari√°vel de um tipo diferente, o que facilita muito lidar com,
por exemplo, endere√ßos de ip, como visto no c√≥digo abaixo:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">enum </span>IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}</code></pre></div>
<p>Por ultimo, mas n√£o menos importante, devido a implenta√ß√£o de mutabilidade como um tipo em Rust, a assinatura das
fun√ß√µes informa muito mais o usu√°rio, uma vez que explicita se a fun√ß√£o modifica, ou n√£o um par√¢metro, o que evita
erros de efeitos colaterais quando usando um biblioteca externa.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>double_1 (list: <span class="kw-2">&amp;mut </span>Vec&lt;u8&gt;);
<span class="kw">fn </span>double_2 (list: <span class="kw-2">&amp;</span>Vec&lt;u8&gt;) -&gt; Vec&lt;u8&gt;;</code></pre></div>
<p>Como podemos ver, apenas pela assinatura podemos saber que a primeira fun√ß√£o modifica o Vetor, enquanto a segunda
retorna um novo vetor baseado nas informa√ß√µes do vetor passado.</p>
<h4 id="capacidade-de-escrita"><a href="#capacidade-de-escrita">Capacidade de Escrita</a></h4>
<p>Uma caracter√≠stica de Rust que aumenta a habilidade de escrita √© como ele lida com o an√°logo dele aos ponteiros de C.
Em rust, um refer√™ncia tamb√©m √© escrita como <code>&amp;var</code> sendo <code>var</code> a vari√°vel que ser√° referenciada. Por√©m,
o programador n√£o precisa adicionar alguma informa√ß√£o (o <code>*</code> do C) para utilizar a
refer√™ncia, basta colocar o par√¢metro que ser√° utilizado, o compilador automaticamente traduz a refer√™ncia
para o valor que deve ser usado.</p>
<p>Em C:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>int cinco = <span class="number">5</span>;
int * ptr = <span class="kw-2">&amp;</span>cinco;
<span class="kw">return </span><span class="number">10 </span>* <span class="kw-2">*</span>(ptr);</code></pre></div>
<p>Em Rust:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>cinco = <span class="number">5</span>;
<span class="kw">let </span>ptr = <span class="kw-2">&amp;</span>cinco;
<span class="kw">return </span><span class="number">10 </span>* ptr;</code></pre></div>
<p>Por outro lado, Rust possui um bom suporte para a abstra√ß√£o, com a adi√ß√£o de m√©todos a structs e enums sendo um bom
exemplo disso. Uma outra forma que Rust aumenta o suporte para a abstra√ß√£o √© a facilidade com que voc√™ pode segregar
diferentes partes do c√≥digo para que um arquivo s√≥ exporte as fun√ß√µes finais que ele implementa, n√£o qualquer uma 
intermediaria, que seja para uso apenas interno.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>Struct Pessoa {
    primeiro_nome: String,
    sobrenome: String,
    cpf: String,
}
 
<span class="kw">impl </span>Pessoa {
    <span class="kw">fn </span>nome_completo(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; String {
        <span class="kw">let </span><span class="kw-2">mut </span>res = <span class="self">self</span>.primeio_nome.clone;
        res.push_str(<span class="kw-2">&amp;</span><span class="self">self</span>.sobrenome);
        res
    }
}</code></pre></div>
<p>Em termos de expressividade e sintaxe, Rust √© bem similar a C.</p>
<p>Um outro ponto que auxilia muito na capacidade de escrita do Rust √© o seu compilador. O Compilador Rust √© muito bom
em encontrar poss√≠veis problemas no c√≥digo, e, quando ele mostra um erro, ele explicita em que parte do c√≥digo o erro foi
cometido, e ainda d√° dicas de como resolver o erro.</p>
<h4 id="confiabilidade"><a href="#confiabilidade">Confiabilidade</a></h4>
<p>Confiabilidade √© a √°rea em que Rust mais se destaca. Como o foco inteiro da linguagem √© seguran√ßa, muito trabalho
foi realizado para que a linguagem seja o mais confi√°vel possivel.</p>
<p>Rust tem uma verifica√ß√£o de tipos est√°tica, em tempo de compila√ß√£o. Mas n√£o s√≥ isso, Rust implementa com tipos
algumas coisas que outras linguagens deixariam a parte, como exce√ß√µes e mutabilidade. A forma como Rust lida com
a checagem de Structs ou Enums que tenham os mesmos tipos internos, mas nomes diferentes √© com a checagem de nomes,
o que tamb√©m aumenta a confiabilidade na linguagem.</p>
<p>Exemplo: Fun√ß√£o de ler arquivos</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">pub fn </span>read&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;Vec&lt;u8&gt;&gt; </code></pre></div>
<p>Temos que tratar de alguma forma o poss√≠vel erro antes de podermos acessar o valor lido. Isso √© implementado usando o enum
Result, visto abaixo.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">enum </span><span class="prelude-ty">Result</span>&lt;T, E&gt; {
    <span class="prelude-val">Ok</span>(T),
    <span class="prelude-val">Err</span>(E),
}</code></pre></div>
<p>Dessa forma, o Usu√°rio √© obrigado a lidar com o erro de alguma forma antes de poder usar o resultado da fun√ß√£o. N√£o
s√≥ isso, mas o Rust incentiva o tratamento de exce√ß√µes e a lidar com diferentes valores de uma vari√°vel com uma express√£o
<code>match</code>, que, embora inicialmente pare√ßa similar a um <code>switch-case</code>, for√ßa o programador a lidar com todos os valores poss√≠veis
para aquela vari√°vel, o que aumenta muito a confiabilidade.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>encrypted_data = <span class="kw">match </span>fs::read(<span class="string">&quot;data&quot;</span>) {
    <span class="prelude-val">Ok</span>(data) =&gt; data,
    <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; <span class="kw">return </span><span class="prelude-val">Err</span>(())
};</code></pre></div>
<p>Mas, o que √© provavelmente a maior raz√£o para a confiabilidade do Rust √© o Borrow-checker. Esta √© um etapa na compila√ß√£o que
imp√µe um conjunto de regras que tem como objetivo minimizar os problemas que o programador pode ter com efeitos colaterais e
os valores dentro de uma fun√ß√£o. O que o Borrow-checker imp√µe √© que cada vari√°vel s√≥ pode ter um ‚Äúdono‚Äù, e, assim que este dono
acaba de ser executado, a vari√°vel √© liberada da mem√≥ria (√© assim que Rust consegue n√£o fazer uso de um Garbage collector). Al√©m disso,
por padr√£o, apenas a fun√ß√£o que √© ‚Äúdona‚Äù da vari√°vel pode modificar a vari√°vel. Nesse vi√©s, para passarmos par√¢metros em Rust, podemos
fazer de 3 formas diferentes.</p>
<p>Passagem por refer√™ncia:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>fun(a: <span class="kw-2">&amp;</span>i32) -&gt; i32 {
    a + <span class="number">10
</span>}
 
<span class="kw">fn </span>main () {
    <span class="kw">let </span>a = <span class="number">1</span>;
    <span class="kw">let </span>b = fun(<span class="kw-2">&amp;</span>a);
    <span class="macro">println!</span>(<span class="string">&quot;a : {}; b : {}&quot;</span>, <span class="kw-2">&amp;</span>a, <span class="kw-2">&amp;</span>b);
}</code></pre></div>
<p>Na passagem por refer√™ncia, a fun√ß√£o que recebe a vari√°vel apenas consegue l√™-la, n√£o edit√°-la, o que evita efeitos colaterais.
Uma vari√°vel pode ser referenciada v√°rias vezes ao mesmo tempo.</p>
<p>Passagem por refer√™ncia mut√°vel:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>fun(a: <span class="kw-2">&amp;mut </span>i32) {
    a += <span class="number">10</span>;
}
 
<span class="kw">fn </span>main () {
    <span class="kw">let </span>a = <span class="number">1</span>;
    fun(<span class="kw-2">&amp;mut </span>a);
    <span class="macro">println!</span>(<span class="string">&quot;a : {};&quot;</span>, <span class="kw-2">&amp;</span>a);
}</code></pre></div>
<p>Na passagem por refer√™ncia mut√°vel, a fun√ß√£o chamada pode modificar a vari√°vel passada, mas a fun√ß√£o chamadora ainda √© a dona
da vari√°vel. Como isso pode causar efeito colateral, apenas um fun√ß√£o pode acessar uma vari√°vel por refer√™ncia mut√°vel por
vez, e n√£o permite que a vari√°vel seja lida at√© que a fun√ß√£o chamada resolva, para evitar efeitos colaterais negativos.</p>
<p>Passagem de posse:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>fun(a: i32) -&gt; i32 {
    a += <span class="number">10</span>;
}
 
<span class="kw">fn </span>main () {
    <span class="kw">let </span>a = <span class="number">1</span>;
    <span class="kw">let </span>a = fun(a);
    <span class="macro">println!</span>(<span class="string">&quot;a : {};&quot;</span>, <span class="kw-2">&amp;</span>a);
}</code></pre></div>
<p>Quando um fun√ß√£o √© chamada por passagem de posse, a fun√ß√£o chamada vira a dona do valor passado, dessa forma, a fun√ß√£o
chamadora perde acesso aquela vari√°vel e n√£o consegue mais utilizar aquela vari√°vel.</p>
<p>Com essas 3 formas de passagem de par√¢metros Rust deixa problemas com valores inesperados de vari√°veis algo praticamente imposs√≠vel
de acontecer.</p>
<h4 id="custo"><a href="#custo">Custo</a></h4>
<ul>
<li>
<p>Custo de treinamento:</p>
<ul>
<li>O Custo de treinamento em Rust √© bem elevado, uma vez que √© uma linguagem bem complexa, com muitos conceitos n√£o observados
em outras linguagens</li>
</ul>
</li>
<li>
<p>Custo para escrever programas</p>
<ul>
<li>Em Rust o custo para escrever programas √© similar ao C, talvez um pouco maior devido ao Borrow-checker, mas isso √©
contrabalanceado pela maior legibilidade</li>
</ul>
</li>
<li>
<p>Custo para compilar programas</p>
<ul>
<li>A primeira compila√ß√£o em Rust √© mais demorada que em C, por√©m, devido a √≥tima ferramenta que √© o cargo, as pr√≥ximas compila√ß√µes
tendem a ser muito mais r√°pidas, devido ao cargo s√≥ compilar as partes modificadas do c√≥digo.</li>
</ul>
</li>
<li>
<p>Custo para executar programas</p>
<ul>
<li>A performance de Rust √© muito similar √† de C.</li>
</ul>
</li>
<li>
<p>Custo do sistema de implementa√ß√£o da linguagem</p>
<ul>
<li>Rust e todas as ferramentas padr√£o utilizadas pela comunidade s√£o open source, ent√£o o custo √© zero.</li>
</ul>
</li>
<li>
<p>Custo da m√° confiabilidade em sistemas cr√≠ticos</p>
<ul>
<li>Rust √© uma das linguagens mais confi√°veis utilizadas ultimamente, uma vez que ativamente pro√≠be problemas que levam a bugs.</li>
</ul>
</li>
<li>
<p>Custo da manuten√ß√£o dos programas</p>
<ul>
<li>Rust tem uma legibilidade maior que C, mas uma capacidade de escrita um pouco pior que C, ent√£o, no geral √© mais f√°cil de
manter uma base de c√≥digo em Rust do que em C.</li>
</ul>
</li>
</ul>
<h4 id="portabilidade"><a href="#portabilidade">Portabilidade</a></h4>
<p>A portabilidade de Rust √© similar a de C, ele deve ser compilado para cada plataforma na qual ele ser√° utilizado, mas suporta
quase todas as plataformas.</p>
<h4 id="generalidade"><a href="#generalidade">Generalidade</a></h4>
<p>Neste quesito, eu diria que Rust √© mais geral que C, uma vez que pode ser aplicado tanto no kernel linux e embarcados, at√© em
aplica√ß√µes web front-end com web assembly.</p>
<h4 id="qualidade-da-defini√ß√£o"><a href="#qualidade-da-defini√ß√£o">Qualidade da defini√ß√£o</a></h4>
<p>Rust tem uma documenta√ß√£o fenomenal, e muitos conte√∫dos online que facilitam o aprendizado, e o funcionamento de todas as 
features.</p>
<h2 id="funcionamento-do-projeto"><a href="#funcionamento-do-projeto">Funcionamento do Projeto</a></h2>
<p>O projeto √© divido em m√≥dulos que implementam cada parte do c√≥digo. Os M√≥dulos est√£o detalhados abaixo.</p>
<p>O c√≥digo pode ser rodado a partir do arquivo em <code>./target/release/cli-password-manager</code>. √â poss√≠vel que o c√≥digo n√£o rode em
algum outro sistema operacional, para o qual o projeto foi compilado. Caso isso seja verdade, o projeto pode ser compilado com
o aux√≠lio do cargo por meio do comando <code>cargo run</code>, esse comando compila e imediatamente roda o execut√°vel.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="encryption/index.html" title="mod cli_password_manager::encryption">encryption</a></div><div class="desc docblock-short">M√≥dulo que lida da encripta√ß√£o e decripta√ß√£o dos dados gerados</div></li><li><div class="item-name"><a class="mod" href="interfaces/index.html" title="mod cli_password_manager::interfaces">interfaces</a></div><div class="desc docblock-short">M√≥dulo que implementa as interfaces que integragem com o usu√°rio</div></li><li><div class="item-name"><a class="mod" href="persistency/index.html" title="mod cli_password_manager::persistency">persistency</a></div><div class="desc docblock-short">M√≥dulo que implementa a persist√™ncia das senhas guardadas</div></li><li><div class="item-name"><a class="mod" href="suggest_password/index.html" title="mod cli_password_manager::suggest_password">suggest_password</a></div><div class="desc docblock-short">M√≥dulo que cria uma senha aleat√≥ria para o usu√°rio</div></li><li><div class="item-name"><a class="mod" href="types/index.html" title="mod cli_password_manager::types">types</a></div><div class="desc docblock-short">M√≥dulo que implementa o tipo b√°sico utilizado pela maioria do projeto</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.main.html" title="fn cli_password_manager::main">main</a><span title="Restricted Visibility">&nbsp;üîí</span> </div><div class="desc docblock-short">¬†Fun√ß√£o geral do c√≥digo, apenas chama a <a href="interfaces/cli/fn.init.html" title="fn cli_password_manager::interfaces::cli::init">fun√ß√£o de iniciar a interface cli</a></div></li></ul></section></div></main></body></html>
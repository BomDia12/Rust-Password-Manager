<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Gerenciador de senhas CLI"><title>cli_password_manager - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-cb6f1f67f1bcd037.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="cli_password_manager" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0 (cc66ad468 2023-10-03)" data-channel="1.73.0" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-1596385f77d47ef2.css" data-theme-dark-css="dark-0a43001d3fc2282c.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-1596385f77d47ef2.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-0a43001d3fc2282c.css"><link rel="stylesheet" href="../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../cli_password_manager/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../cli_password_manager/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate cli_password_manager</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.1.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">cli_password_manager</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/cli_password_manager/main.rs.html#1-239">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="gerenciador-de-senhas-cli"><a href="#gerenciador-de-senhas-cli">Gerenciador de senhas CLI</a></h2>
<p>Este projeto foi desenvolvido em Rust no contexto da disciplina Linguagens de Programção
ministrada pelo professor Marcelo Ladeira. Ele visa explorar a linguagem Rust que foi escolhida pela turma
como a Linguagem a ser usada no desenvolvimento dos projetos.</p>
<h2 id="desenvolvedores"><a href="#desenvolvedores">Desenvolvedores</a></h2>
<ul>
<li>Ana Paula Oliveira da Nóbrega Costa (190142120)</li>
<li>Arthur Mota Furtado (200014935)</li>
<li>Gabriel Cruz Vaz Santos (200049038)</li>
<li>Nícolas Paulin Benatto (200025627)</li>
<li>Vanessa Paixão Costa (200028286)</li>
</ul>
<h2 id="características-da-linguagem-rust"><a href="#características-da-linguagem-rust">Características da Linguagem Rust</a></h2>
<p>Rust foi uma linguagem de programação desenvolvida por Graydon Hoare, e lançada em 2015. Ela tem como domínio
principal da linguagem o desenvolvimento de sistemas, e é uma linguagem multi-paradigmas, com ferramentas que 
permitem que ela seja utilizada tanto como uma linguagem imperativa, orientada a objetos, ou funcional.</p>
<p>Durante o seu desenvolvimento, o principal foco que rust teve foi em seguraça de memória, com um compilador,
que força um conjunto de regras, visando uma maior segurança em código Rust. Não só isso, mas o funcionamento
do Borrow-checker, uma inovação do Rust, que propõe uma nova forma de lidar com variáveis, permite que o
programador não lide diretamente com gerenciamento de memória, mas retira a necessidade de um Garbage collector,
algo que diminui a performance das aplicações de linguagens que a implementam.</p>
<p>Um outro foco que Rust teve, em seu desenvolvimento, é a criação de arquivos compilados pequenos, o que permite que
seja uma linguagem com grande aplicabilidade no setor de embarcados.</p>
<h3 id="avaliaçao-da-linguagem-em-relação-aos-critérios-de-avaliação"><a href="#avaliaçao-da-linguagem-em-relação-aos-critérios-de-avaliação">Avaliaçao da linguagem em relação aos critérios de avaliação</a></h3><h4 id="legibilidade"><a href="#legibilidade">Legibilidade</a></h4>
<p>Rust é uma linguagem muito estruturada, e, uma vez que o programador é familiar com o funcionamento
da linguagem, a forma como o compilador força o código a ser escrito é muito mais fácil de se entender
do que é possível em uma linguagem como C.</p>
<p>Um exmplo claro disso, é a forma como Rust implementa mutabilidade. Por padrão, as variáveis em Rust são constantes
e tem que ter um tipo a mais (<code>mut</code>) para serem mutáveis. Dessa forma, o programador, ao ler o código, entende
exatamente quais variáveis serão mudadas ao longo do desenvolvimento e quais não serão.</p>
<p>Rust tem muitas ferramentas que facilitam a leitura de código, uma das principais é o seu robusto sistema de tipagem.
Em Rust, todos os tipos básicos são bem intuitivos, com os inteiros (<code>u8</code>, <code>i8</code>, <code>u16</code>, …), por exemplo,
explicitando se o tipo possui sinal, e quantos bits o tipo tem (algo mais intuitivo que <code>char</code>, <code>short</code>, <code>int</code>,
<code>long</code> e <code>long long</code>). Porém, as estruturas de dados mais poderosas de Rust tem que ser Enums, e Structs. Embora
inicialmente sejam parecidas com as estruras similares em C, elas possuem algumas ferramentas que as tornam muito
mais úteis.</p>
<p>Quando se trata de Structs, em Rust, elas têm um funcionamento similar a Classes, em linguagem orientadas a objetos.
Por meio da keyword <code>impl</code> é possível implementar métodos para essas Structs, tanto métodos gerais, que não necessitam de
uma instância da Struct, quanto métodos específicos, que utlizam ou modificam o objeto que chamou a função. Além
disso, quando uma Struct é declarada em um módulo, ela pode especificar quais propriedades da Struct são públicas
e quais são privadas.</p>
<p>Em relação a Enums, Rust os suporta como uma das principais estruturas de dados da linguagem. Tendo isso em vista,
Rust permite que cada valor enumerado receba uma variável de um tipo diferente, o que facilita muito lidar com,
por exemplo, endereços de ip, como visto no código abaixo:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">enum </span>IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}</code></pre></div>
<p>Além disso, Rust também permite a implementação de métodos novos para Enums, assim como para Structs.</p>
<p>Por ultimo, mas não menos importante, devido a implentação de mutabilidade como um tipo em Rust, a assinatura das
funções informa muito mais o usuário, uma vez que explicita se a função modifica, ou não um parâmetro, o que evita
erros de efeitos colaterais quando usando um biblioteca externa.</p>
<h4 id="capacidade-de-escrita"><a href="#capacidade-de-escrita">Capacidade de Escrita</a></h4>
<p>Uma característica de Rust que aumenta a habilidade de escrita é como ele lida com o análogo dele aos ponteiros de C.
Em rust, um referência também é escrita como <code>&amp;var</code> sendo <code>var</code> a variável que será referenciada. Porém,
o programador não precisa adicionar alguma informação (o <code>*</code> do C) para utilizar a
referência, basta colocar o parâmetro que será utilizado, o compilador automaticamente traduz a referência
para o valor que deve ser usado.</p>
<p>Em termos mais gerais, não tem uma capacidade de escrita muito elevada. Como o principal foco de Rust é confiança e
segurança, o compilador aplica muitas regras que o programador deve seguir, se não o programa não compila. Um bom
exemplo disso é o borrow-checker, que deixa a passagem de parâmetros muito mais complicada em Rust.</p>
<p>Por outro lado, Rust possui um bom suporte para a abstração, com a adição de métodos a structs e enums sendo um bom
exemplo disso. Uma outra forma que Rust aumenta o suporte para a abstração é a facilidade com que você pode segregar
diferentes partes do código para que um arquivo só exporte as funções finais que ele implementa, não qualquer uma 
intermediaria, que seja para uso apenas interno.</p>
<p>Em termos de expressividade e sintaxe, Rust é bem similar a C.</p>
<p>Um outro ponto que auxilia muito na capacidade de escrita do Rust é o seu compilador. O Compilador Rust é muito bom
em encontrar possíveis problemas no código, e, quando ele mostra um erro, ele explicita em que parte do código o erro foi
cometido, e ainda dá dicas de como resolver o erro.</p>
<h4 id="confiabilidade"><a href="#confiabilidade">Confiabilidade</a></h4>
<p>Confiabilidade é a área em que Rust mais se destaca. Como o foco inteiro da linguagem é segurança, muito trabalho
foi realizado para que a linguagem seja o mais confiável possivel.</p>
<p>Rust tem uma verificação de tipos estática, em tempo de compilação. Mas não só isso, Rust implementa com tipos
algumas coisas que outras linguagens deixariam a parte, como exceções e mutabilidade. A forma como Rust lida com
a checagem de Structs ou Enums que tenham os mesmos tipos internos, mas nomes diferentes é com a checagem de nomes,
o que também aumenta a confiabilidade na linguagem.</p>
<p>Tratamento de exceções. Rust é muito bom no quesito tratamento de exceções. Como dito anteriormente, Rust lida com
exceções, na maioria das vezes como um tipo, com funções que podem falhar retornando o seguinte Enum:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">enum </span><span class="prelude-ty">Result</span>&lt;T, E&gt; {
    <span class="prelude-val">Ok</span>(T),
    <span class="prelude-val">Err</span>(E),
}</code></pre></div>
<p>Dessa forma, o Usuário é obrigado a lidar com o erro de alguma forma antes de poder usar o resultado da função. Não
só isso, mas o Rust incentiva o tratamento de exceções e a lidar com diferentes valores de uma variável com uma expressão
<code>match</code>, que, embora inicialmente pareça similar a um <code>switch-case</code>, força o programador a lidar com todos os valores possíveis
para aquela variável, o que aumenta muito a confiabilidade.</p>
<p>Mas, o que é provavelmente a maior razão para a confiabilidade do Rust é o Borrow-checker. Esta é um etapa na compilação que
impõe um conjunto de regras que tem como objetivo minimizar os problemas que o programador pode ter com efeitos colaterais e
os valores dentro de uma função. O que o Borrow-checker impõe é que cada variável só pode ter um “dono”, e, assim que este dono
acaba de ser executado, a variável é liberada da memória (é assim que Rust consegue não fazer uso de um Garbage collector). Além disso,
por padrão, apenas a função que é “dona” da variável pode modificar a variável. Nesse viés, para passarmos parâmetros em Rust, podemos
fazer de 3 formas diferentes.</p>
<p>Passagem por referência:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>fun(a: <span class="kw-2">&amp;</span>i32) -&gt; i32 {
    a + <span class="number">10
</span>}
 
<span class="kw">fn </span>main () {
    <span class="kw">let </span>a = <span class="number">1</span>;
    <span class="kw">let </span>b = fun(<span class="kw-2">&amp;</span>a);
    <span class="macro">println!</span>(<span class="string">&quot;a : {}; b : {}&quot;</span>, <span class="kw-2">&amp;</span>a, <span class="kw-2">&amp;</span>b);
}</code></pre></div>
<p>Na passagem por referência, a função que recebe a variável apenas consegue lê-la, não editá-la, o que evita efeitos colaterais.
Uma variável pode ser referenciada várias vezes ao mesmo tempo.</p>
<p>Passagem por referência mutável:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>fun(a: <span class="kw-2">&amp;mut </span>i32) {
    a += <span class="number">10</span>;
}
 
<span class="kw">fn </span>main () {
    <span class="kw">let </span>a = <span class="number">1</span>;
    fun(<span class="kw-2">&amp;mut </span>a);
    <span class="macro">println!</span>(<span class="string">&quot;a : {};&quot;</span>, <span class="kw-2">&amp;</span>a);
}</code></pre></div>
<p>Na passagem por referência mutável, a função chamada pode modificar a variável passada, mas a função chamadora ainda é a dona
da variável. Como isso pode causar efeito colateral, apenas um função pode acessar uma variável por referência mutável por
vez, e não permite que a variável seja lida até que a função chamada resolva, para evitar efeitos colaterais negativos.</p>
<p>Passagem de posse:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>fun(a: i32) -&gt; i32 {
    a += <span class="number">10</span>;
}
 
<span class="kw">fn </span>main () {
    <span class="kw">let </span>a = <span class="number">1</span>;
    <span class="kw">let </span>a = fun(a);
    <span class="macro">println!</span>(<span class="string">&quot;a : {};&quot;</span>, <span class="kw-2">&amp;</span>a);
}</code></pre></div>
<p>Quando um função é chamada por passagem de posse, a função chamada vira a dona do valor passado, dessa forma, a função
chamadora perde acesso aquela variável e não consegue mais utilizar aquela variável.</p>
<p>Com essas 3 formas de passagem de parâmetros Rust deixa problemas com valores inesperados de variáveis algo praticamente impossível
de acontecer.</p>
<h4 id="custo"><a href="#custo">Custo</a></h4>
<ul>
<li>
<p>Custo de treinamento:</p>
<ul>
<li>O Custo de treinamento em Rust é bem elevado, uma vez que é uma linguagem bem complexa, com muitos conceitos não observados
em outras linguagens</li>
</ul>
</li>
<li>
<p>Custo para escrever programas</p>
<ul>
<li>Em Rust o custo para escrever programas é similar ao C, talvez um pouco maior devido ao Borrow-checker, mas isso é
contrabalanceado pela maior legibilidade</li>
</ul>
</li>
<li>
<p>Custo para compilar programas</p>
<ul>
<li>A primeira compilação em Rust é mais demorada que em C, porém, devido a ótima ferramenta que é o cargo, as próximas compilações
tendem a ser muito mais rápidas, devido ao cargo só compilar as partes modificadas do código.</li>
</ul>
</li>
<li>
<p>Custo para executar programas</p>
<ul>
<li>A performance de Rust é muito similar à de C.</li>
</ul>
</li>
<li>
<p>Custo do sistema de implementação da linguagem</p>
<ul>
<li>Rust e todas as ferramentas padrão utilizadas pela comunidade são open source, então o custo é zero.</li>
</ul>
</li>
<li>
<p>Custo da má confiabilidade em sistemas críticos</p>
<ul>
<li>Rust é uma das linguagens mais confiáveis utilizadas ultimamente, uma vez que ativamente proíbe problemas que levam a bugs.</li>
</ul>
</li>
<li>
<p>Custo da manutenção dos programas</p>
<ul>
<li>Rust tem uma legibilidade maior que C, mas uma capacidade de escrita um pouco pior que C, então, no geral é mais fácil de
manter uma base de código em Rust do que em C.</li>
</ul>
</li>
</ul>
<h4 id="portabilidade"><a href="#portabilidade">Portabilidade</a></h4>
<p>A portabilidade de Rust é similar a de C, ele deve ser compilado para cada plataforma na qual ele será utilizado, mas suporta
quase todas as plataformas.</p>
<h4 id="generalidade"><a href="#generalidade">Generalidade</a></h4>
<p>Neste quesito, eu diria que Rust é mais geral que C, uma vez que pode ser aplicado tanto no kernel linux e embarcados, até em
aplicações web front-end com web assembly.</p>
<h4 id="qualidade-da-definição"><a href="#qualidade-da-definição">Qualidade da definição</a></h4>
<p>Rust tem uma documentação fenomenal, e muitos conteúdos online que facilitam o aprendizado, e o funcionamento de todas as 
features.</p>
<h2 id="funcionamento-do-projeto"><a href="#funcionamento-do-projeto">Funcionamento do Projeto</a></h2>
<p>O projeto é divido em módulos que implementam cada parte do código. Os Módulos estão detalhados abaixo.</p>
<p>O código pode ser rodado a partir do arquivo em <code>./target/release/cli-password-manager</code>. É possível que o código não rode em
algum outro sistema operacional, para o qual o projeto foi compilado. Caso isso seja verdade, o projeto pode ser compilado com
o auxílio do cargo por meio do comando <code>cargo run</code>, esse comando compila e imediatamente roda o executável.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="encryption/index.html" title="mod cli_password_manager::encryption">encryption</a></div><div class="desc docblock-short">Módulo que lida da encriptação e decriptação dos dados gerados</div></li><li><div class="item-name"><a class="mod" href="interfaces/index.html" title="mod cli_password_manager::interfaces">interfaces</a></div><div class="desc docblock-short">Módulo que implementa as interfaces que integragem com o usuário</div></li><li><div class="item-name"><a class="mod" href="persistency/index.html" title="mod cli_password_manager::persistency">persistency</a></div><div class="desc docblock-short">Módulo que implementa a persistência das senhas guardadas</div></li><li><div class="item-name"><a class="mod" href="suggest_password/index.html" title="mod cli_password_manager::suggest_password">suggest_password</a></div><div class="desc docblock-short">Módulo que cria uma senha aleatória para o usuário</div></li><li><div class="item-name"><a class="mod" href="types/index.html" title="mod cli_password_manager::types">types</a></div><div class="desc docblock-short">Módulo que implementa o tipo básico utilizado pela maioria do projeto</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.main.html" title="fn cli_password_manager::main">main</a><span title="Restricted Visibility">&nbsp;🔒</span> </div><div class="desc docblock-short"> Função geral do código, apenas chama a <a href="cli::login_menu">função de login da interface cli</a></div></li></ul></section></div></main></body></html>